## 建测点13.1 用7ch中断例程完成loop指令的功能
```assebmle
assume cs:code

code segment 
    mov ax, 4c00h
    int 21h
start: 
    ; 设置起点
    mov ax, cs
    mov ds, ax
    mov si, offset mock_loop
    ; 设置循环次数
    mov cx, offset end_i - offset mock_loop
    ; 设置复制的目标地
    mov ax, 0
    mov es, ax
    mov di, 200
    ; 设置复制方向
    cld
    ; 执行复制
    rep movsb

    mov bx, 1F0H
    ; 设置中断向量表
    ; 设置ip
    mov byte ptr es:[1F0H], 200
    ; 设置cs
    mov byte ptr es:[1F2H], 0
    
    mov ax, 0b800H
    mov es, ax
    mov di, 160 * 12
    mov bx, offset s - offset se
    mov cx, 80

s:  mov byte ptr es:[di], '!'
    add di, 2
    int 7ch
se:
    nop
    
    mov ax, 4c00h
    int 21h

mock_loop:
    ; 这里用到了bp，把bp压入栈
    push bp
    ; 将栈顶位置赋给bp
    mov bp, sp 
    ; 递减cx
    dec cx
    ; 如果cx为0则执教跳转到end_mock_loop并返回原来的程序
    jcxz end_mock_loop
    add [bp + 2], bx

end_mock_loop:
    pop bp
    iret
end_i:
    nop

code ends

end start
```

该部分的重点主要在*mock_loop*、和设置中断程序部分。
1. 在上面内容中，我们用7CH中断例程实现loop功能，则上面的7CH中断例程所能进行的最大转移位移是多少？
    - 答：因为bx为16位寄存器，由于我们是将其作为有符号数看待的，所以**转移的最大范围应是32768**（不是65535！为什么不能是FFFFH？？？因为转移可以往前也可以往后，所以应该是有符号数！）
2. 用7ch中断例程完成jmp near ptr s指令功能，用bx向中断例程传送转移位移。
    - 答：操作指令和原来的段内转移差不多，就是需要多处理一个段地址。

## 检测点13.2 
判断下面说法的正误：

1. 我们可以编程改变FFFF:0处的指令，使得CPU不去执行BIOS中的硬件系统检测和初始化程序。
    - 答案：错误！编程是在基于整个系统启动的基础上进行，整个系统尚未启动，无法直接对硬件底层进行干预（要是说如果直接干预硬件的编写，那倒是可能）。

2. int 19h中断例程，可以由DOS提供。
    - 答案：错误！这个问题可以理解为是先有鸡还是先有蛋，在BIOS和DOS的中断例程安装过程中，我们可以得知要先安装BIOS的中断例程，调用`int 19H`才能引导操作系统工作。
