# 检测点11.1
![检测点11.1问题](https://blog-1252749790.cos.ap-shanghai.myqcloud.com/assemble/jiancedian11.1.png)

1. ZF = 1, PF = 1, SF = 0
2. ZF = 1, PF = 1, SF = 0
3. ZF = 1, PF = 1, SF = 0
4. ZF = 1, PF = 1, SF = 0
5. ZF = 0, PF = 0, SF = 0
6. ZF = 0, PF = 1, SF = 0
7. ZF = 0, PF = 1, SF = 0

注意这里的SF是根据保存最终结果的寄存器的位数来的
```assemble
mov ax, 1
add ax, 7F ; 0111 1111B + 1 = 1000 0000B。而实际执行后SF=0，因为add最终会保存到ax寄存器内，且ax为16位寄存器，完整的看，ax寄存器实际为0000 0000 1000 0000B，所以SF != 0

mov ax, 1
add al, 7F ; 0111 1111B + 1 = 1000 0000B。add指令最终将结果保存在al内，而al为8位寄存器，完整的看al寄存器内的数为1000 0000B，最高位为1，所以SF = 0

mov ax, FFFF
mov cx, FF00
mul cx     ; 发现DX寄存器的最高位为1，但是SF不是1，推测SF不受mul指令影响
```

# 检测点11.2
![检测点11.2问题](https://blog-1252749790.cos.ap-shanghai.myqcloud.com/assemble/jiancedian11.2.png)

|             | CF | OF | SF | ZF | PF |
| ----------- | -- | -- | -- | -- | -- |
| sub al, al  | 0  | 0  | 0  | 1  | 1  |
| mov al,10H  | 0  | 0  | 0  | 1  | 1  |
| add al, 90H | 0  | 0  | 1  | 0  | 1  |
| mov al, 80H | 0  | 0  | 1  | 0  | 1  |
| add al,80H  | 1  | 1  | 0  | 1  | 1  |
| mov al,0FCH | 1  | 1  | 0  | 1  | 1  |
| add al, 05H | 1  | 0  | 0  | 0  | 0  |
| mov al,7DH  | 1  | 0  | 0  | 0  | 0  |
| add al,0BH  | 0  | 1  | 1  | 0  | 1  |

# 检测点11.3
## （1）统计个数
补全下面的程序，统计F000:0处32个字节中，大小在[32，128]的数据的个数
```assemble
    mov ax,0f000h
    mov ds,ax
    mov bx,0
    mov dx,0
    mov cx,32
    s:mov al,[bx]
      cmp al,32
      ____①_____
      cmp al,128                        
      ____②_____
      inc dx 
    s0:inc bx
       loop s
```
A：
1. jb s0 
     - 解析：首先这里是dx保存数据个数，bx表示浮标；所以为了让al低于32时跳转到s0处——这里需要使用到 jb指令，表示 al < 32 的话就跳转s0标号处（al >= 32就不跳转）
2. ja s0
     - 解析：这里得判断al不能大于32，所以这里需要使用到 ja指令，表示 al > 128 的话就跳转到s0标号处（al <= 128就不跳转）

### 补全下面的程序，统计F000:0处32个字节中，大小在(32，128)的数据的个数
## （2）统计个数
```assemble
    mov ax,0f000h
    mov ds,ax
    mov bx,0
    mov dx,0
    mov cx,32
    s:mov al,[bx]
      cmp al,32
      _________  
      cmp al,128
      _________  
      inc dx
    s0:inc bx
      loop s
```
A：
1. jna s0，al不大于32就跳转到s0，也就是说al大于32就继续执行
2. jnb s0，al不小于128就跳转到s0，也就是说al小于128就继续执行