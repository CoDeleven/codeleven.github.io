# 检测点10.1
```assemble
assume cs:code
stack segment
    db 16 dup (0)
stack ends

code segment
start:  
        ;建栈
        mov ax,stack
        mov ss,ax
        mov sp,16
        ;压栈
        mov ax, ____①____

        push ax
        mov ax, ____②____ 
        push ax
        retf

        mov ax,4c00H
        int 21H

code ends
end start
```

**Q: 补全程序，实现从内存1000:0000处开始执行指令**

A: 

1. 1000H
2. 0

# 检测点10.2
![检测点10.2](https://blog-1252749790.cos.ap-shanghai.myqcloud.com/assemble/jiancedian10.2.png)

Q: 上面的程序执行后，ax中的数值为多少？

A: ax = 6

# 检测点10.3
![检测点10.3](https://blog-1252749790.cos.ap-shanghai.myqcloud.com/assemble/jiancedian10.3.png)

Q: 上面的程序执行后，ax中的数值为多少？

A: ax = 1010H 

分析：

1. `call far ptr a` 将**cs=1000**压入栈，**ip=3**压入栈（call指令后的第一条指令的地址压入栈）
2. `pop ax` 后**ax=8H**、**bx=1000H**
3. 不解释了


# 检测点10.4
![检测点10.4](https://blog-1252749790.cos.ap-shanghai.myqcloud.com/assemble/jiancedian10.4.png)

Q: 上面的程序执行后，ax中的数值为多少？

A: ax = 0BH

# 检测点10.5
![检测点10.5](https://blog-1252749790.cos.ap-shanghai.myqcloud.com/assemble/jiancedian10.5.png)

A: ax = 3

分析：

1. `call word ptr ds:[0EH]` 先将**IP（第一条inc ax）** 压入栈，随后从栈中去除最新压入的数值（因为整个栈的大小为**0FH**，所以压入一个数值后，**SP指向0EH**），即IP。
2. 跳转过去后就是三条连着的`inc ax`，从而得到**ax=3**

# 检测点10.6
![检测点10.6](https://blog-1252749790.cos.ap-shanghai.myqcloud.com/assemble/jiancedian10.6png.png)

Q: 下面的程序执行后，ax和bx中的数值为多少？

A: ax = 1, bx = 0

分析：

1. `mov word ptr ss:[0], offset s`后，`ss:[0]`的**字地址** 保存了s的偏移量
2. `mov ss:[2], cs`后，`ss:[2]`的**字地址** 保存了cs
3. 调用了`call`指令后，`ss:[0EH]`的**字地址** 里面保存了cs，`ss:[0CH]`的**字地址里**保存了 **nop指令所在的地址**
4. `sub ax, ss:[0CH]`后，ax=1
5. 后面一个同理可得，bx = 0

