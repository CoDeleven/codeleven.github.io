---
title: 存储器之主存结构
date: 2018-07-17 08:28:13
tags: 计算机组成
---

# 概要
前面了解过，CPU速度 提升的会越来越快，存储芯片速度 提升的相比来说就会比较慢。比如CPU五年提高50%，存储芯片10年提高50%。
因为CPU需要的程序、数据都在存储器里；CPU又需要将计算结果存储在存储器里；所以如果两者的执行速度差就会越来越大，那么即使CPU速度再快也无济于事。
这种问题在业界内称为 **存储墙问题**

所以为了提高存储芯片的性能，我们前面介绍了以下几种方法：
* 提高芯片性能（SRAM、DRAM等等）
* 存储系统的层次结构（CPU-缓存-主存）

本节就是要讲另外一种提高存储器速度的方法：**改变主存内部的结构**


# 主存的结构

## 单体多字处理系统
单体多字系统的核心在于：扩展存储字长。
比如原来是一个 存储字长（=机器字长），现在将存储字长提高为原来的N倍。

假设现在机器字长为16位，存储字长为64位。如下图所示：

![单体多字处理系统](https://blog-1252749790.file.myqcloud.com/ComputerOrganization/%E5%8D%95%E4%BD%93%E5%A4%9A%E5%AD%97%E7%B3%BB%E7%BB%9F.png)

单体多字处理系统的要点：
1. 图中存储体那行，其实分成了四块（每一块的存储字长都是和机器字长相等的，即16位），共组成了一个64位的存储单元
2. 当CPU要获取数据时，先将 **一个存储单元内**的数据（即64位） 读到 **数据寄存器**中，下一次要用时可以直接用

这样就能提高存储器的带宽，但是它也有自己的缺点：
1. CPU每次写入时，由于只能写入16位的数据，所以每次都需要先写入图中的单字寄存器，然后由单字寄存器写回存储体。但是对于存储体来说，每次应该写入64位，所以在写入过程中可能会发生误伤的情况（覆盖了不必要的数据）
2. CPU读取数据时，如果数据不是连续的，就会产生浪费。比如读到一条指令，该指令要跳转到后面的存储地址，那么此次读就会产生浪费


## 多体并行之高位交叉
多体并行的核心在于：让多个存储体并行操作，每个存储体有各自独立的地址寄存器（MAR）、数据寄存器（MDR）、地址译码、驱动电路、读/写电路等等。而高位交叉如下图所示

![多体并行之高位交叉](https://blog-1252749790.file.myqcloud.com/ComputerOrganization/%E5%A4%9A%E4%BD%93%E7%B3%BB%E7%BB%9F%E4%B9%8B%E9%AB%98%E4%BD%8D%E4%BA%A4%E5%8F%89.png)

高位表示体号、低位表示体内地址（可以参考字扩展），由于程序因按体内地址顺序存放（一个体存满后，再存入下一个体），故又有顺序存储之称。这种编码方式，只要合理调动，使不同的请求源访问不同的体，便可实现并行工作。

缺点：
如果CPU经常访问同一个个体，其他个体就会空闲着，就会产生“一体有难，三核围观”的现象。

## 多体并行之低位交叉（又称交叉存储）
多体并行就不赘述了，这里讲一下低位交叉，因为高位交叉是顺序存储的，只有当一个存储体全部用完后才会使用后面的存储体，所以多体并行就可能发生CPU一直访问一个存储体，而不访问其他存储体的问题。

而低位交叉正好解决了这个问题，让低位作为体号，高位作为体内地址，如下图所示

![多体并行之低位交叉](https://blog-1252749790.file.myqcloud.com/ComputerOrganization/%E5%A4%9A%E4%BD%93%E7%B3%BB%E7%BB%9F%E4%B9%8B%E4%BD%8E%E4%BD%8D%E4%BA%A4%E5%8F%89.png)

每次先将第一排放满，再放第二排，第三排...

## 多体并行的总结
虽然对于每个存储操作来说，周期没有缩短，但由于CPU交叉访问各体，使四个存储体的读/写重叠在一起，最终在一个存储周期内完成，存储器向CPU提供了四个存储字。时间关系如下图所示

![交叉访问的时间关系](https://blog-1252749790.file.myqcloud.com/ComputerOrganization/%E4%BA%A4%E5%8F%89%E8%AE%BF%E9%97%AE%E7%9A%84%E6%97%B6%E9%97%B4%E5%85%B3%E7%B3%BB.png)

当发生一次访问时，