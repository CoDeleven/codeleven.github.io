---
title: 《深入Java虚拟机》之对象内存布局及使用
date: 2018-05-27 10:22:13
tags: JVM
---

## Q1. 对象什么时候创建
当虚拟机遇到`new`关键字时，首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否被加载。如果没有执行相应的加载过程，这部分内容可以看类的加载流程。

## Q2. 对象在哪里创建
对象要创建时必须要为新对象分配内存空间，即在Java堆中划分出一块等大小的内存区域。然而并不是所有的对象都在堆上分配，存在一种叫做 **栈上分配** 的技术，先判断待创建对象是否发生逃逸，如果没有就将对象打散成不可分割的变量，分配在栈上。该技术通过 **逃逸分析** 和 **标量替换** 得以实现。

[逃逸分析、标量替换相关文章](https://www.jianshu.com/p/580f17760f6e)

## Q3. 怎么分配空间
根据内存区域是否完整、连续，将Java堆划分为两种情况：
* 指针碰撞：该情况是指Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，当分配内存时，就将指针向空闲内存空间移动一段和内存大小一样的距离即可
* 空闲列表：如果Java堆中的内存是不规整的，已使用的内存和空闲内存相互交错，虚拟机就必须维护一个列表，记录上哪些内存是可用的，在分配时从列表中找到一块足够大的内存空间划分给对象实例

选择哪种方式存放内存是由 **java堆是否规整** 决定的，而Java堆是否规整又是由 **所采用的垃圾收集器是否带有压缩整理功能** 决定的。因此，在使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。

可能不同代的内存，分配方式可能不一样。

## Q4. 对象创建时指针的同步问题
在并发情况中，可能正在为A分配内存空间，指针没来得及移动；对象B又同时使用了原来的指针来分配内存。虚拟机处理这种情况的方法也有两种：
* 对分配内存空间的情况进行同步——采用CAS + 失败重试 的方式保证更新操作的原子性
* 另一种是把内存分配的动作按照线程划分在不同的空间中，即每个线程在Java堆中预先分配一块内存，称为 **本地线程分配缓存（TLAB）** 。线程分配的对象放置在各自的TLAB中，等TLAB的空间用完后要分配新的内存空间时，才需要重新同步锁定。用 `-XX:+/-UseTLAB` 开启或关闭TLAB

## Q5. 内存分配完毕后做什么
1. 初始化内存空间
2. 对象头的设置
3. 调用初始化方法

内存分配完后的第一步就是先将分配到的内存空间初始化为默认值；如果使用TLAB，这一工作过程也可以 **提前至TLAB分配时进行**

对象头的设置包括元数据、对象的锁标志位、对象的分代年龄等等，而根据虚拟机的运行状态不同，还会有不同的设置

最后执行<init>方法（构造函数），将所有字段按程序员的意愿进行初始化，此时，这个对象才算是真正可用

## Q6.对象在内存里有什么
* 对象头
     - 存储对象自身运行时的数据
     - 类型指针
     - 若对象为数组，还需保存数组的长度
* 实例数据
* 对齐填充

### 对象头
对象头通常包含两个部分，**第一个部分** 用于保存对象运行时的数据，该部分又称 **MarkWord**，保存着如哈希码、GC分代年龄、锁状态标志、线程持有的锁等等信息，这部分在32位虚拟机里占32位，64位虚拟机里占64位（不开启指针压缩）。MarkWord被设计为不定长的数据结构，它会根据运行状态复用自己的存储空间(是未锁定、轻量级锁定等等)。

**第二个部分** 是类型指针，虚拟机通过这个指针确定 **这个对象是哪个类的实例**
**第三个部分** 是当对象为数组时才存在的，主要用于记录数组的长度

### 实例数据
对象真正存储的有效数据

### 对齐填充
因为HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍，对象头部分正好是8字节的整数倍，因此当实例数据没有对齐时，就需要对齐填充。对齐填充是提高效率的一种方法，并且有些CPU如果不内存对齐，程序会直接崩溃；

[内存对齐的目的](https://stackoverflow.com/questions/381244/purpose-of-memory-alignment)


## Q7. 创建完一个对象后，如何访问对象实例
使用对象的方法是，通过栈上的reference数据来操作堆上的具体对象。由于Java虚拟机规范中只规定了Reference类型是一个指向对象的引用，并没有定义这个引用通过何种方式去定位。目前主流的方式有两种：

* 使用句柄，该方案会在Java堆中划分一块区域作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体信息
![句柄引用示意图](https://blog-1252749790.file.myqcloud.com/jvm/reference_by_handle.png)
* 直接指针，reference存储的地址直接是对象地址，对象实例数据里会包含数据类型信息
![直接引用示意图](https://blog-1252749790.file.myqcloud.com/jvm/reference_by_direct.png)

句柄引用的优势是移动对象实例后（比如GC情况下），reference变量不需要改变指向的地址。
直接引用的优势是速度快，节省了一次定位的开销。积少成多后，提高的速度也是很客观的

[找出栈、堆上的引用类型](http://rednaxelafx.iteye.com/blog/1044951)

虚拟机具体采用哪一种引用方式是根据 **虚拟机是否记录类型信息** 而决定的，而且该决定会影响GC的实现方式。通常按准确程度划分为以下三种：
* 保守式
* 半保守式
* 准确式

### 保守式GC
当无法区分内存上某个位置的数据究竟是引用类型还是整数类型时（或其他类型），我们称它为保守式GC。当发生GC时，JVM从一些已知的位置开始扫描内存（比如栈，如果是堆就查找对象里面是否有引用类型的属性）并递归深入，如果满足下面的条件就认为它是一个引用类型：
* 四字节对齐
* 里面的数值在堆范围内（比如数值为100，堆的范围为0-1000，那么就认为是在堆里面）
* The allocbit is set. The allocbit is a flag indicating whether the memory location corresponding to it is allocated or not.

缺点：
* 部分应该死的对象没死；当内存需求量大时，这些本应该释放掉的内存没被释放，总归不是一件好事
* 由于无法确切的知道一个变量究竟是基本类型还是引用类型，所以对象发生移动时，无法确切的得知哪些变量应该被修改。简单来说，保守式GC里的对象无法被移动；若是想要移动对象，必须增加一个中间层，即 **句柄**。所有指针都先指向句柄池，再从句柄里找到对象。这样要移动对象就只需要修改句柄表的内容即可。

### 半保守式
由于JVM要支持丰富的反射功能，本来对象就会带上一堆元数据，所以自己所有属性的类型信息都可以一目了然。
所以在扫描堆时，JVM可以直接根据对象带有的信息判断 **该对象内什么位置是什么类型的变量**
而在扫描栈时，仍然需要一个个扫描，且无法判断某个位置上具体是什么变量

改进：
* 由于半保守式在堆内部的数据类型是准确可知的，所以大部分情况下可以采用 **直接引用**，也就可以支持部分对象的移动（对在栈上扫描出来的对象进行标记，表示 “不可移动对象”，而对象属性里的引用仍可以移动）

### 准确式
和保守式相反——能区分内存（包括栈和堆）上任意位置的数据类型。HotSpot里采用 **从外部记录类型信息，存成映射表**，在HotSpot里该映射表被叫做 `OopMap`。要实现这项功能，需要虚拟机里的解释器和JIT编译器共同的支持，由它们来生成足够的元数据信息。

使用这样的映射表一般有两种方式： 
1、每次都遍历原始的映射表，循环的一个个偏移量扫描过去；这种用法也叫“解释式”； 
2、为每个映射表生成一块定制的扫描代码（想像扫描映射表的循环被展开的样子），以后每次要用映射表就直接执行生成的扫描代码；这种用法也叫“编译式”。 

对于堆里的对象，`OopMap`里记录了该类型的对象内什么偏移量上是什么类型的数据。这些数据是在类的加载过程中计算出来的。

对于栈来说就会比较麻烦。每个被JIT编译后的方法都会在一些 **特定的位置**记录下`OopMap`，记录了执行到该方法的某条指令的时候，栈上和寄存器里哪些位置是引用。特定位置主要在：

* 循环的末尾
* 方法临返回前/调用方法的call指令后
* 可能抛出异常的位置

这些位置被成为 **安全点**。由于每个位置都记录 `OopMap` 很浪费空间，所以选择几个关键的位置就能有效缩减需要记录的数据量，但仍然能达到区分数据类型的作用。

在解释器中执行的方法则可以通过解释器自动生成出 `OopMap`出来给GC用。

注意，这里分成了两部分，一部分是解释器的操作，一部分是JIT编译的操作。
两个什么区别可以看[这篇文章](https://blog.csdn.net/sunxianghuang/article/details/52094859)
