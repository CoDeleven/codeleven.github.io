标志寄存器同普通的寄存器一样有16位，它的主要作用就是提供一些程序的状态字段，简称**程序状态字**

# ZF（零状态寄存器）
当使用 运算指令（比如add、sub、mul等）时，可能会修改ZF位;而传送指令（比如mov、pop、push等）就不会修改ZF位。当执行了运算指令后结果为 **0** 则 **ZF=1**，如果结果不为 **0** 则 **ZF=0**

```assemble
    sub al, al ;执行完后ZF=1
    add al, 1  ;执行完后ZF=0
```

# PF（奇偶标志位）
该位表示一个数据的所有比特位中 **1的个数** 是否为偶数，如果 **1的个数** 为偶数，那么PF = 1；反之则为0

```assemble
    sub al, al ; PF = 1
    add al, 3  ; PF = 0
```

# SF（符号标志位）
该位表示该数据是否带有符号，即是否是负数。而该寄存器仅当开发人员在**做有符号运算时才生效**，这句话怎么理解？众所周知，计算机其实就是一堆或非门组成的，其本质上就是一堆01组成的无符号数（正数），而人们为了表示负数，将bit位的最高位作为符号位，也就是说负数是人为加上去的，一堆01可以看成是无符号数，也能看成是有符号数。而程序是不知道人类如何思考的，所以索性使用SF寄存器，如果最高为是1，我给你把SF设置为1，你用不用是你的事。

注意，这里的mul、div指令均不会对SF产生影响。

```assemble
    mov al 0000 0001B ;可以看作无符号数 1，也能看作有符号数 1
    mov al 1000 0001B ;可以看作是无符号数 129，也能看做是有符号数 -127 
```

# CF（进位标志位）
进位标志位在进行无符号运算时，记录了运算结果的最高有效位向更高位的进位值（或借位值）。换句话说就是当两个数相加，不够保存时（超出当前最大位数）**CF=1**，而当两个数相减时，
![进位标志位作用示意图](https://blog-1252749790.cos.ap-shanghai.myqcloud.com/assemble/zhishidian11.4.png)