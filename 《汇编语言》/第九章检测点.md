# 检测点9.1（1）
```assemble
assume cs:code

data segment
    ____?______
data ends
code segment
start:
    mov ax,data
    mov ds,ax
    mov bx,0
    jmp word ptr [bx+1]
code ends
    end start
```

Q: 若要使程序中的jmp指令执行后，CS:IP指向程序的第一条指令，在data段中应定义哪些数据？

A: 想要让此时的`CS:IP`指向程序的第一条，只要`[bx + 1]`这个**字单元（因为是word ptr）** 保存着**数值0**即可，所以`data`里面前三个字节保存0即可。

这道题帮我解决了一个认知错误：
以前一直在想，把`IP`直接设为0能回到第一行代码吗？今天折腾这道题的时候翻书发现原来有两种写法：

1. 将数据也写在**代码段**里面，也就是栈、数据、代码写在一个段里面，那么第一行代码通常不是可执行指令，所以想jmp回第一行代码，不能直接将IP设置为0
```assemble
assume cs:code
code segment
    db 'welcome to masm!'
start:
    mov ax,data
    mov ds,ax
    mov bx,0
    jmp word ptr [bx+1]
code ends
    end start
```

2. 将栈、数据、代码分到各个段里面，然后通过指令`end`设定待执行的第一行代码，此时的`CS`和`IP`都指向标号处的代码(也就是下例中start标号起始的那行代码)。此时直接将IP设置为0，能直接指向`code`段中的第一行代码，因为`data`段和`code`段相隔64K（也就是FFFF），`end`指令已经将`cs`段寄存器设置为`code`，所以可以无后顾之忧地将IP设置为0指向`code`段的第一行代码。
```assemble
assume cs:code

data segment
    db 0, 0, 0
data ends
code segment
    mov ax, 0
start:
    mov ax,data
    mov ds,ax
    mov bx,0
    jmp word ptr [bx+1]
code ends
    end start
```

# 检测点9.1（2）
```assemble
assume cs:code

data segment
    dd 12345678H
data ends

code segment
start:  mov ax,data
        mov ds,ax
        mov bx,0
        mov [bx], ___①____
        mov [bx+2], ___②___
        jmp dword ptr ds:[0]

        mov ax,4c00H
        int 21H
code ends

end start
```
Q：补全程序，使cs：ip指向程序的第一条指令。

A：
①：bx(反正总得传个0进去)
②：code|start标号
分析：低位放IP地址，高位放CS地址


# 检测点9.1（3）
用Debug查看内存，结果如下：

2000:1000 BE 00 06 00 00 00 ......

则此时，CPU执行指令：

mov ax,2000h

mov es,ax

jmp dword ptr es:[1000h]

Q:执行程序后，（CS）=?，（IP）=?

A:(CS) = 0006，(IP) = 00BE

# 检测点9.2
![检测点9.2](https://blog-1252749790.cos.ap-shanghai.myqcloud.com/assemble/jiancedian9.2.png)

A：

1. mov cl, [bx]
2. mov ch, 0
3. jcxz ok
4. inc bx



# 检测点9.3
assume cs:code

code segment

start:  mov ax,2000h
        mov ds,ax
        mov bx,0

      s:mov cl,[bx]
        mov ch,0
        ________
        inc bx
        loop s

     ok:dec bx
        mov dx,bx
        mov ax,4c00h
        int 21h
code ends

end start

Q: 补全编程，利用loop指令，实现在内存2000H段中查找第一个值为0的字节，找到后，将它的偏移地址存储在dx中。
A: 
①：inc cx

因为loop指令先执行 **--cx**，后判断cx是否为0从而决定是否执行跳转；


# 实验8
![实验8](https://blog-1252749790.cos.ap-shanghai.myqcloud.com/assemble/exp8.png)

A:

程序分析：

1. end start，从start标号开始执行
2. 前两个指令均为`NOP`空指令，跳过即可
3. `mov di, offset s`设置di为s，即保存地
4. `mov si, offset s2`设置si为s2，即源数据
5. `mov ax, cs:[si]`将s2的两个字节保存到ax中
6. `mov cs:[di], ax`将ax设置到保存地中
7. `jmp short s`跳转到s处
8. s处保存的地址是s2的`jmp short s1`，`mov ax, 0`占用3个字节，`int 21h`占用2个字节，所以s1总共占用8个字节；`jmp short s1`占用2个字节，nop占用1一个字节，所以`jmp short s1`的偏移量应该为 **-10**；
    - s处保存的`jmp short s1`占用两个字节
    - s处上方的`mov ax, 0`占用三个字节
    - s处上方的`int 21h`占用两个字节
    - s处上方的`mov ax, 4c00h`占用三个字节
    
    所以在s处执行`jmp short s1`后，回到第一行代码`mov ax, 4c00h`
9. 程序能正常结束

